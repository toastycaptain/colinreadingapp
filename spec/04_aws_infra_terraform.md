# Storytime Video Library — AWS Infrastructure as Code Spec (Terraform-first)
> **Goal:** Provision AWS infrastructure for **S3 + CloudFront + MediaConvert** so the Rails backend can:
> - issue presigned uploads to a **private master bucket**
> - trigger MediaConvert jobs
> - serve HLS outputs via **CloudFront** backed by a **private output bucket**
> - restrict playback with **CloudFront Signed Cookies** (Key Group + Public Key)
>
> This spec is written for **Terraform**. Codex should implement Terraform modules/files matching this document.
> (CDK optional later.)

---

## 0) High-Level Architecture

### Buckets
1. **Master uploads bucket** (private): `storytime-master-uploads-<env>`  
   - Stores original MP4/MOV.
   - Upload via **presigned POST/PUT** from admin console.
2. **HLS output bucket** (private): `storytime-hls-outputs-<env>`  
   - Stores HLS manifests + segments produced by MediaConvert.
   - Readable only by CloudFront using **Origin Access Control (OAC)**.

### CloudFront
- Distribution with OAC to the HLS output bucket
- Default behavior for HLS paths `books/*`
- HLS manifests: `index.m3u8`
- Segments: `.ts` (or fMP4 if you choose CMAF later)
- Access restricted with **Signed Cookies** using a **Key Group**

### MediaConvert
- IAM service role used by MediaConvert:
  - Read from master bucket
  - Write to output bucket
- Job template or job settings generated by Rails (MVP) using AWS SDK.

### Secrets
- CloudFront private key stored in **AWS Secrets Manager**
- Rails reads secret at runtime to sign cookies.

---

## 1) Terraform Structure (Recommended)

Create a folder:
```
infra/
  envs/
    dev/
      main.tf
      variables.tf
      outputs.tf
      terraform.tfvars
    prod/
      main.tf
      variables.tf
      outputs.tf
      terraform.tfvars
  modules/
    s3_bucket/
    cloudfront_hls/
    iam_roles/
    mediaconvert/
    secrets/
  README.md
```

Use separate state per env (S3 backend + DynamoDB lock).

---

## 2) Variables (per environment)

Required variables (examples):
- `aws_region`
- `project_name` = "storytime"
- `environment` = "dev" | "prod"
- `domain_name` (optional, if using custom CDN domain)
- `acm_certificate_arn` (required if custom domain)
- `cloudfront_key_pair_id` (value created after public key)
- `cloudfront_public_key_pem` (PEM string for public key)
- `cloudfront_private_key_secret_name` (Secrets Manager secret name)
- `tags` map

---

## 3) S3 Buckets

### 3.1 Master uploads bucket
Terraform requirements:
- `aws_s3_bucket`
- Enable:
  - Block Public Access (all true)
  - Versioning optional (recommended)
  - SSE-S3 or SSE-KMS (recommended)
- Lifecycle policy:
  - Optionally move old masters to Glacier after 30–90 days

**CORS**
Allow browser-based direct uploads from admin domain(s):
- AllowedMethods: `PUT`, `POST`, `GET`, `HEAD`
- AllowedOrigins: your admin console origin(s)
- AllowedHeaders: `*`
- ExposeHeaders: `ETag`

### 3.2 HLS output bucket
- Block public access
- SSE-S3 or SSE-KMS
- No CORS needed unless debugging in-browser playback (iOS uses AVPlayer so no browser CORS)

---

## 4) CloudFront Distribution (HLS)

### 4.1 Origin Access Control (OAC)
Create `aws_cloudfront_origin_access_control` for S3 origin.
- origin type: s3
- signing behavior: always
- signing protocol: sigv4

### 4.2 Bucket policy for output bucket (allow CloudFront)
Add policy allowing CloudFront distribution to read objects:
- Principal: `cloudfront.amazonaws.com`
- Condition: `AWS:SourceArn` = distribution ARN
- Actions: `s3:GetObject`
- Resource: `arn:aws:s3:::storytime-hls-outputs-<env>/*`

### 4.3 Cache & behaviors
- Default root object: none
- Behavior for `books/*`:
  - Viewer protocol: redirect-to-https
  - Allowed methods: GET/HEAD
  - Compress: true
  - Cache policy tuned for HLS:
    - cache based on headers minimal
    - query strings: none (unless you introduce tokens; signed cookies do not need query strings)
- TTLs:
  - Manifests: consider shorter TTL (e.g., 60s) if you expect rapid changes
  - Segments: longer TTL (e.g., 1 day)
MVP: Use a single cache policy; refine later.

### 4.4 Signed Cookies: Key Group + Public Key
Terraform must create:
- `aws_cloudfront_public_key` using `cloudfront_public_key_pem`
- `aws_cloudfront_key_group` referencing that public key
- Attach key group to the behavior’s trusted key groups

**Important:** The Rails backend will generate cookies with:
- CloudFront-Policy
- CloudFront-Signature
- CloudFront-Key-Pair-Id (this ID comes from CloudFront public key, not the TF var, but surface it via outputs)

### 4.5 Custom domain (optional)
If you want `cdn.storytime.com`:
- Use Route53 record `A/AAAA` alias to distribution
- ACM certificate in **us-east-1** for CloudFront
- Set distribution aliases

---

## 5) IAM Roles & Policies

### 5.1 MediaConvert service role
Create `aws_iam_role` assumed by `mediaconvert.amazonaws.com` with policy:
- Read master bucket:
  - `s3:GetObject`, `s3:GetObjectVersion`, `s3:ListBucket`
- Write output bucket:
  - `s3:PutObject`, `s3:AbortMultipartUpload`, `s3:ListBucket`, `s3:GetBucketLocation`
- CloudWatch Logs (optional):
  - `logs:CreateLogGroup`, `logs:CreateLogStream`, `logs:PutLogEvents`

Output the role ARN for Rails to use in job settings.

### 5.2 Rails app IAM permissions
Assuming Rails runs on ECS/EKS/EC2 or Heroku with AWS credentials:
- Permissions needed:
  - S3 presign capability (does not require special actions beyond S3 actions used by presigned policy generation, but app needs AWS credentials)
  - `s3:PutObject` is NOT used directly if you only presign; but many teams still grant minimal `s3:PutObject` on the master bucket prefix for server-side workflows.
  - MediaConvert:
    - `mediaconvert:CreateJob`
    - `mediaconvert:GetJob`
    - `mediaconvert:ListJobs` (optional)
  - Secrets Manager:
    - `secretsmanager:GetSecretValue` for CloudFront private key

Codex should define an IAM policy document for the Rails app role/user.

---

## 6) MediaConvert Setup

### 6.1 MediaConvert endpoint discovery
MediaConvert requires using an account-specific endpoint.
Rails should:
- call `DescribeEndpoints` once and cache result.

Terraform:
- No hard requirement to create endpoint; it’s AWS-managed.
- Ensure correct IAM permissions.

### 6.2 Job template (optional)
You can create a MediaConvert Job Template in Terraform for consistent settings:
- HLS output group
- multiple renditions
- output naming
- destination path: accept variable substitution? (MediaConvert templates do not dynamically substitute book_id, so Rails may still provide full job settings).
MVP recommendation:
- Rails generates job settings per book_id and uses a shared pattern.

---

## 7) Secrets Manager (CloudFront Private Key)

Create:
- `aws_secretsmanager_secret` named like `storytime/<env>/cloudfront_private_key`
- `aws_secretsmanager_secret_version` with the PEM (for dev) or created out-of-band (for prod)

**Security note:** For prod, do NOT store PEM in terraform state. Instead:
- Create the secret resource in Terraform
- Inject secret value manually or via CI/CD secret manager integration
- Terraform should not manage the secret payload in prod.

Outputs:
- secret ARN
- secret name

---

## 8) Outputs (Used by Rails)

Terraform outputs must include:
- `master_uploads_bucket_name`
- `hls_outputs_bucket_name`
- `cloudfront_distribution_id`
- `cloudfront_domain_name`
- `cloudfront_key_group_id`
- `cloudfront_public_key_id`
- `mediaconvert_role_arn`
- `cloudfront_private_key_secret_arn` (or name)

Rails environment variables should be populated from these outputs.

---

## 9) Validation Checklist

After apply:
1. Upload a test file to master bucket via presigned URL.
2. Trigger a MediaConvert job writing to output bucket.
3. Confirm output `index.m3u8` and segment files exist.
4. Confirm CloudFront can fetch those objects (via OAC).
5. Confirm unauthenticated requests to CloudFront HLS paths are denied **if** you enforce signed cookies at the app layer (CloudFront itself won’t deny without signed cookies unless you require them via trusted key group).  
6. Generate signed cookies and verify playback works in a test client.

---

## 10) Deliverables for Codex (Infra)
Codex should produce:
- Terraform module(s) implementing:
  - two S3 buckets with policies/CORS
  - CloudFront distribution with OAC and trusted key group
  - CloudFront public key + key group
  - MediaConvert IAM role
  - Secrets Manager secret (resource only for prod)
  - Optional Route53 + ACM alias
- Environment-specific configs for dev/prod
- A README with:
  - how to init/apply
  - how to rotate CloudFront keys
  - how to inject private key secret in prod

